#![allow(clippy::enum_variant_names)]

#[repr(u16)]
#[derive(Debug, Clone, PartialEq, Eq)]
/// [Class Access Flags](https://docs.oracle.com/javase/specs/jvms/se17/jvms17.pdf#page=85)
pub enum ClassAccessFlags {
    None = 0x0000,
    /// Declared public; may be accessed from outside its package.
    AccPublic = 0x0001,
    /// Declared private; accessible only within the
    /// defining class and other classes belonging to the same
    /// nest (ยง5.4.4).
    AccPrivate = 0x0002,
    /// Declared protected; may be accessed within
    /// subclasses.
    AccProtected = 0x0004,
    /// Declared static.
    AccStatic = 0x0008,
    /// Declared final; no subclasses allowed.
    AccFinal = 0x0010,
    /// Treat superclass methods specially when invoked by\
    /// the invokespecial instruction.
    AccSuper = 0x0020,
    /// Is an interface, not a class.
    AccInterface = 0x0200,
    /// Declared abstract; must not be instantiated.
    AccAbstract = 0x0400,
    /// Declared synthetic; not present in the source code.
    AccSynthetic = 0x1000,
    /// Declared as an annotation interface.
    AccAnnotation = 0x2000,
    /// Declared as an enum class.
    AccEnum = 0x4000,
    /// Is a module, not a class or interface.
    AccModule = 0x8000,
}

impl ClassAccessFlags {
    pub fn from_u16(value: u16) -> Vec<Self> {
        let mut flags = vec![];
        if value & ClassAccessFlags::AccPublic as u16 == ClassAccessFlags::AccPublic as u16 {
            flags.push(ClassAccessFlags::AccPublic);
        }
        if value & ClassAccessFlags::AccPrivate as u16 == ClassAccessFlags::AccPrivate as u16 {
            flags.push(ClassAccessFlags::AccPrivate);
        }
        if value & ClassAccessFlags::AccProtected as u16 == ClassAccessFlags::AccProtected as u16 {
            flags.push(ClassAccessFlags::AccProtected);
        }
        if value & ClassAccessFlags::AccStatic as u16 == ClassAccessFlags::AccStatic as u16 {
            flags.push(ClassAccessFlags::AccStatic);
        }
        if value & ClassAccessFlags::AccFinal as u16 == ClassAccessFlags::AccFinal as u16 {
            flags.push(ClassAccessFlags::AccFinal);
        }
        if value & ClassAccessFlags::AccSuper as u16 == ClassAccessFlags::AccSuper as u16 {
            flags.push(ClassAccessFlags::AccSuper);
        }
        if value & ClassAccessFlags::AccInterface as u16 == ClassAccessFlags::AccInterface as u16 {
            flags.push(ClassAccessFlags::AccInterface);
        }
        if value & ClassAccessFlags::AccAbstract as u16 == ClassAccessFlags::AccAbstract as u16 {
            flags.push(ClassAccessFlags::AccAbstract);
        }
        if value & ClassAccessFlags::AccSynthetic as u16 == ClassAccessFlags::AccSynthetic as u16 {
            flags.push(ClassAccessFlags::AccSynthetic);
        }
        if value & ClassAccessFlags::AccAnnotation as u16 == ClassAccessFlags::AccAnnotation as u16
        {
            flags.push(ClassAccessFlags::AccAnnotation);
        }
        if value & ClassAccessFlags::AccEnum as u16 == ClassAccessFlags::AccEnum as u16 {
            flags.push(ClassAccessFlags::AccEnum);
        }
        if value & ClassAccessFlags::AccModule as u16 == ClassAccessFlags::AccModule as u16 {
            flags.push(ClassAccessFlags::AccModule);
        }
        flags
    }
}

impl From<&ClassAccessFlags> for String {
    fn from(value: &ClassAccessFlags) -> Self {
        match value {
            ClassAccessFlags::None => "none",
            ClassAccessFlags::AccPublic => "public",
            ClassAccessFlags::AccPrivate => "private",
            ClassAccessFlags::AccProtected => "protected",
            ClassAccessFlags::AccStatic => "static",
            ClassAccessFlags::AccFinal => "final",
            ClassAccessFlags::AccSuper => "super",
            ClassAccessFlags::AccInterface => "interface",
            ClassAccessFlags::AccAbstract => "abstract",
            ClassAccessFlags::AccSynthetic => "synthetic",
            ClassAccessFlags::AccAnnotation => "annotation",
            ClassAccessFlags::AccEnum => "enum",
            ClassAccessFlags::AccModule => "module",
        }
        .into()
    }
}

#[repr(u16)]
#[derive(Debug, Clone, PartialEq, Eq)]
/// [Method Access Flags](https://docs.oracle.com/javase/specs/jvms/se17/jvms17.pdf#page=112)
pub enum MethodAccessFlags {
    None = 0x0000,
    /// Declared public; may be accessed from outside its package.
    AccPublic = 0x0001,
    /// Declared private; accessible only within the
    /// defining class and other classes belonging to the same
    /// nest (ยง5.4.4).
    AccPrivate = 0x0002,
    /// Declared protected; may be accessed within
    /// subclasses.
    AccProtected = 0x0004,
    /// Declared static.
    AccStatic = 0x0008,
    /// Declared final; no subclasses allowed.
    AccFinal = 0x0010,
    /// Declared synchronized; invocation is wrapped
    /// by a monitor use.
    AccSynchronized = 0x0020,
    /// A bridge method, generated by the compiler.
    AccBridge = 0x0040,
    /// Declared with variable number of arguments.
    AccVarArgs = 0x0080,
    /// Declared native; implemented in a language other
    /// than the Java programming language.
    AccNative = 0x0100,
    /// Declared abstract; must not be instantiated.
    AccAbstract = 0x0400,
    /// In a class file whose major version number is at
    /// least 46 and at most 60: Declared strictfp.
    AccStrict = 0x0800,
    /// Declared synthetic; not present in the source code.
    AccSynthetic = 0x1000,
}

impl MethodAccessFlags {
    pub fn from_u16(value: u16) -> Vec<Self> {
        let mut flags = vec![];
        if value & MethodAccessFlags::AccPublic as u16 == MethodAccessFlags::AccPublic as u16 {
            flags.push(MethodAccessFlags::AccPublic);
        }
        if value & MethodAccessFlags::AccPrivate as u16 == MethodAccessFlags::AccPrivate as u16 {
            flags.push(MethodAccessFlags::AccPrivate);
        }
        if value & MethodAccessFlags::AccProtected as u16 == MethodAccessFlags::AccProtected as u16
        {
            flags.push(MethodAccessFlags::AccProtected);
        }
        if value & MethodAccessFlags::AccStatic as u16 == MethodAccessFlags::AccStatic as u16 {
            flags.push(MethodAccessFlags::AccStatic);
        }
        if value & MethodAccessFlags::AccFinal as u16 == MethodAccessFlags::AccFinal as u16 {
            flags.push(MethodAccessFlags::AccFinal);
        }
        if value & MethodAccessFlags::AccSynchronized as u16
            == MethodAccessFlags::AccSynchronized as u16
        {
            flags.push(MethodAccessFlags::AccSynchronized);
        }
        if value & MethodAccessFlags::AccBridge as u16 == MethodAccessFlags::AccBridge as u16 {
            flags.push(MethodAccessFlags::AccBridge);
        }
        if value & MethodAccessFlags::AccVarArgs as u16 == MethodAccessFlags::AccVarArgs as u16 {
            flags.push(MethodAccessFlags::AccVarArgs);
        }
        if value & MethodAccessFlags::AccNative as u16 == MethodAccessFlags::AccNative as u16 {
            flags.push(MethodAccessFlags::AccNative);
        }
        if value & MethodAccessFlags::AccAbstract as u16 == MethodAccessFlags::AccAbstract as u16 {
            flags.push(MethodAccessFlags::AccAbstract);
        }
        if value & MethodAccessFlags::AccStrict as u16 == MethodAccessFlags::AccStrict as u16 {
            flags.push(MethodAccessFlags::AccStrict);
        }
        if value & MethodAccessFlags::AccSynthetic as u16 == MethodAccessFlags::AccSynthetic as u16
        {
            flags.push(MethodAccessFlags::AccSynthetic);
        }
        flags
    }
}

impl From<&MethodAccessFlags> for String {
    fn from(value: &MethodAccessFlags) -> Self {
        match value {
            MethodAccessFlags::None => "none",
            MethodAccessFlags::AccPublic => "public",
            MethodAccessFlags::AccPrivate => "private",
            MethodAccessFlags::AccProtected => "protected",
            MethodAccessFlags::AccStatic => "static",
            MethodAccessFlags::AccFinal => "final",
            MethodAccessFlags::AccSynchronized => "synchronized",
            MethodAccessFlags::AccBridge => "bridge",
            MethodAccessFlags::AccVarArgs => "varargs",
            MethodAccessFlags::AccNative => "native",
            MethodAccessFlags::AccAbstract => "abstract",
            MethodAccessFlags::AccStrict => "strict",
            MethodAccessFlags::AccSynthetic => "synthetic",
        }
        .into()
    }
}

#[repr(u16)]
#[derive(Debug, Clone)]
pub enum FieldAccessFlags {
    None = 0x0000,
    /// Declared public; may be accessed from outside its package.
    AccPublic = 0x0001,
    /// Declared private; accessible only within the
    /// defining class and other classes belonging to the same
    /// nest (ยง5.4.4).
    AccPrivate = 0x0002,
    /// Declared protected; may be accessed within
    /// subclasses.
    AccProtected = 0x0004,
    /// Declared static.
    AccStatic = 0x0008,
    /// Declared final; no subclasses allowed.
    AccFinal = 0x0010,
    /// Declared volatile; cannot be cached.
    AccVolatile = 0x0040,
    /// Declared transient; not written or read by a
    /// persistent object manager.
    AccTransient = 0x0080,
    /// Declared synthetic; not present in the source code.
    AccSynthetic = 0x1000,
    /// Declared as an enum class.
    AccEnum = 0x4000,
}

impl FieldAccessFlags {
    pub fn from_u16(value: u16) -> Vec<Self> {
        let mut flags = vec![];
        if value & FieldAccessFlags::AccPublic as u16 == FieldAccessFlags::AccPublic as u16 {
            flags.push(FieldAccessFlags::AccPublic);
        }
        if value & FieldAccessFlags::AccPrivate as u16 == FieldAccessFlags::AccPrivate as u16 {
            flags.push(FieldAccessFlags::AccPrivate);
        }
        if value & FieldAccessFlags::AccProtected as u16 == FieldAccessFlags::AccProtected as u16 {
            flags.push(FieldAccessFlags::AccProtected);
        }
        if value & FieldAccessFlags::AccStatic as u16 == FieldAccessFlags::AccStatic as u16 {
            flags.push(FieldAccessFlags::AccStatic);
        }
        if value & FieldAccessFlags::AccFinal as u16 == FieldAccessFlags::AccFinal as u16 {
            flags.push(FieldAccessFlags::AccFinal);
        }
        if value & FieldAccessFlags::AccVolatile as u16 == FieldAccessFlags::AccVolatile as u16 {
            flags.push(FieldAccessFlags::AccVolatile);
        }
        if value & FieldAccessFlags::AccTransient as u16 == FieldAccessFlags::AccTransient as u16 {
            flags.push(FieldAccessFlags::AccTransient);
        }
        if value & FieldAccessFlags::AccSynthetic as u16 == FieldAccessFlags::AccSynthetic as u16 {
            flags.push(FieldAccessFlags::AccSynthetic);
        }
        if value & FieldAccessFlags::AccEnum as u16 == FieldAccessFlags::AccEnum as u16 {
            flags.push(FieldAccessFlags::AccEnum);
        }
        flags
    }
}

impl From<&FieldAccessFlags> for String {
    fn from(value: &FieldAccessFlags) -> Self {
        match value {
            FieldAccessFlags::None => "none",
            FieldAccessFlags::AccPublic => "public",
            FieldAccessFlags::AccPrivate => "private",
            FieldAccessFlags::AccProtected => "protected",
            FieldAccessFlags::AccStatic => "static",
            FieldAccessFlags::AccFinal => "final",
            FieldAccessFlags::AccVolatile => "volatile",
            FieldAccessFlags::AccTransient => "transient",
            FieldAccessFlags::AccSynthetic => "synthetic",
            FieldAccessFlags::AccEnum => "enum",
        }
        .into()
    }
}

#[repr(u16)]
#[derive(Debug, Clone)]
pub enum ParameterAccessFlags {
    /**
     * *ACC_FINAL*\
     *  Indicates that the formal parameter was declared final
     */
    AccFinal = 0x0010,
    /**
     * *ACC_SYNTHETIC*\
     *  Indicates that the formal parameter was not explicitly or implicitly
     *  declared in source code, according to the specification of the language
     *  in which the source code was written (JLS ยง13.1). (The formal
     *  parameter is an implementation artifact of the compiler which
     *  produced this class file.)
     */
    AccSynthetic = 0x1000,
    /**
     * *ACC_Mandated*\
     *  Indicates that the formal parameter was implicitly declared in source
     *  code, according to the specification of the language in which the source
     *  code was written (JLS ยง13.1). (The formal parameter is mandated by a
     *  language specification, so all compilers for the language must emit it.)
     */
    AccMandated = 0x8000,
}

impl ParameterAccessFlags {
    pub fn from_u16(value: u16) -> Vec<Self> {
        let mut flags = vec![];
        if value & ParameterAccessFlags::AccFinal as u16 == ParameterAccessFlags::AccFinal as u16 {
            flags.push(ParameterAccessFlags::AccFinal);
        }
        if value & ParameterAccessFlags::AccSynthetic as u16
            == ParameterAccessFlags::AccSynthetic as u16
        {
            flags.push(ParameterAccessFlags::AccSynthetic);
        }
        if value & ParameterAccessFlags::AccMandated as u16
            == ParameterAccessFlags::AccMandated as u16
        {
            flags.push(ParameterAccessFlags::AccMandated);
        }
        flags
    }
}

impl From<&ParameterAccessFlags> for String {
    fn from(value: &ParameterAccessFlags) -> Self {
        match value {
            ParameterAccessFlags::AccFinal => "final",
            ParameterAccessFlags::AccSynthetic => "synthetic",
            ParameterAccessFlags::AccMandated => "mandated",
        }
        .into()
    }
}

pub mod module_flags {
    #[repr(u16)]
    #[derive(Debug, Clone)]
    pub enum ModuleAccessFlags {
        /**
         * *ACC_OPEN*\
         *  Indicates that this module is open.
         */
        AccOpen = 0x0020,
        /**
         * *ACC_SYNTHETIC*\
         *  Indicates that this module was not explicitly or implicitly declared.
         */
        AccSynthetic = 0x1000,
        /**
         * *ACC_Mandated*\
         *  Indicates that this module was implicitly declared.
         */
        AccMandated = 0x8000,
    }

    impl ModuleAccessFlags {
        pub fn from_u16(value: u16) -> Vec<Self> {
            let mut flags = vec![];
            if value & ModuleAccessFlags::AccOpen as u16 == ModuleAccessFlags::AccOpen as u16 {
                flags.push(ModuleAccessFlags::AccOpen);
            }
            if value & ModuleAccessFlags::AccSynthetic as u16
                == ModuleAccessFlags::AccSynthetic as u16
            {
                flags.push(ModuleAccessFlags::AccSynthetic);
            }
            if value & ModuleAccessFlags::AccMandated as u16
                == ModuleAccessFlags::AccMandated as u16
            {
                flags.push(ModuleAccessFlags::AccMandated);
            }
            flags
        }
    }

    impl From<&ModuleAccessFlags> for String {
        fn from(value: &ModuleAccessFlags) -> Self {
            match value {
                ModuleAccessFlags::AccOpen => "open",
                ModuleAccessFlags::AccSynthetic => "synthetic",
                ModuleAccessFlags::AccMandated => "mandated",
            }
            .into()
        }
    }

    #[repr(u16)]
    #[derive(Debug, Clone)]
    pub enum RequiresAccessFlags {
        /**
         * *ACC_TRANSITIVE*\
         *  Indicates that any module which depends on the current module,
         *  implicitly declares a dependence on the module indicated by this entry.
         */
        AccTransistive = 0x0020,
        /**
         * *ACC_STATIC_PHASE*\
         *  Indicates that this dependence is mandatory in the static phase, i.e., at
         *  compile time, but is optional in the dynamic phase, i.e., at run time.
         */
        AccStaticPhase = 0x0040,
        /**
         * *ACC_SYNTHETIC*\
         *  Indicates that this dependence was not explicitly or implicitly declared
         *  in the source of the module declaration.
         */
        AccSynthetic = 0x1000,
        /**
         * *ACC_Mandated*\
         *  Indicates that this dependence was implicitly declared in the source of
         *  the module declaration.
         */
        AccMandated = 0x8000,
    }

    impl RequiresAccessFlags {
        pub fn from_u16(value: u16) -> Vec<Self> {
            let mut flags = vec![];
            if value & RequiresAccessFlags::AccTransistive as u16
                == RequiresAccessFlags::AccTransistive as u16
            {
                flags.push(RequiresAccessFlags::AccTransistive);
            }
            if value & RequiresAccessFlags::AccStaticPhase as u16
                == RequiresAccessFlags::AccStaticPhase as u16
            {
                flags.push(RequiresAccessFlags::AccStaticPhase);
            }
            if value & RequiresAccessFlags::AccSynthetic as u16
                == RequiresAccessFlags::AccSynthetic as u16
            {
                flags.push(RequiresAccessFlags::AccSynthetic);
            }
            if value & RequiresAccessFlags::AccMandated as u16
                == RequiresAccessFlags::AccMandated as u16
            {
                flags.push(RequiresAccessFlags::AccMandated);
            }
            flags
        }
    }

    impl From<&RequiresAccessFlags> for String {
        fn from(value: &RequiresAccessFlags) -> Self {
            match value {
                RequiresAccessFlags::AccTransistive => "trasnsistive",
                RequiresAccessFlags::AccStaticPhase => "static_phase",
                RequiresAccessFlags::AccSynthetic => "synthetic",
                RequiresAccessFlags::AccMandated => "mandated",
            }
            .into()
        }
    }

    #[repr(u16)]
    #[derive(Debug, Clone)]
    pub enum ExportsAccessFlags {
        /**
         * *ACC_SYNTHETIC*\
         *  Indicates that this export was not explicitly or implicitly declared in
         *  the source of the module declaration.
         */
        AccSynthetic = 0x1000,
        /**
         * *ACC_Mandated*\
         *  Indicates that this export was implicitly declared in the source of the
         *  module declaration.
         */
        AccMandated = 0x8000,
    }

    impl ExportsAccessFlags {
        pub fn from_u16(value: u16) -> Vec<Self> {
            let mut flags = vec![];
            if value & ExportsAccessFlags::AccSynthetic as u16
                == ExportsAccessFlags::AccSynthetic as u16
            {
                flags.push(ExportsAccessFlags::AccSynthetic);
            }
            if value & ExportsAccessFlags::AccMandated as u16
                == ExportsAccessFlags::AccMandated as u16
            {
                flags.push(ExportsAccessFlags::AccMandated);
            }
            flags
        }
    }

    impl From<&ExportsAccessFlags> for String {
        fn from(value: &ExportsAccessFlags) -> Self {
            match value {
                ExportsAccessFlags::AccSynthetic => "synthetic",
                ExportsAccessFlags::AccMandated => "mandated",
            }
            .into()
        }
    }

    #[repr(u16)]
    #[derive(Debug, Clone)]
    pub enum OpensAccessFlags {
        /**
         * *ACC_SYNTHETIC*\
         *  Indicates that this opening was not explicitly or implicitly declared in
         *  the source of the module declaration.
         */
        AccSynthetic = 0x1000,
        /**
         * *ACC_Mandated*\
         *  Indicates that this opening was implicitly declared in the source of the
         *  module declaration.
         */
        AccMandated = 0x8000,
    }

    impl OpensAccessFlags {
        pub fn from_u16(value: u16) -> Vec<Self> {
            let mut flags = vec![];
            if value & OpensAccessFlags::AccSynthetic as u16
                == OpensAccessFlags::AccSynthetic as u16
            {
                flags.push(OpensAccessFlags::AccSynthetic);
            }
            if value & OpensAccessFlags::AccMandated as u16 == OpensAccessFlags::AccMandated as u16
            {
                flags.push(OpensAccessFlags::AccMandated);
            }
            flags
        }
    }

    impl From<&OpensAccessFlags> for String {
        fn from(value: &OpensAccessFlags) -> Self {
            match value {
                OpensAccessFlags::AccSynthetic => "synthetic",
                OpensAccessFlags::AccMandated => "mandated",
            }
            .into()
        }
    }
}
